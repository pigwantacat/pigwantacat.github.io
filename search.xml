<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql如何解决幻读问题</title>
      <link href="/2021/07/04/MySql%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98/"/>
      <url>/2021/07/04/MySql%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>参考于：</p><p><a href="https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc">面试官：谈谈你对Mysql的MVCC的理解？ (baidu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/66791480">一文理解Mysql MVCC - 知乎 (zhihu.com)</a></p><p><a href="https://www.php.cn/mysql-tutorials-460111.html">全网最全的一篇数据库MVCC详解，不全我负责-mysql教程-PHP中文网</a></p><p><a href="https://www.cnblogs.com/wwcom123/p/10727194.html">【MySQL】当前读、快照读、MVCC - wwcom123 - 博客园 (cnblogs.com)</a></p><p>[MySQL 是如何解决幻读的 - 吴丹阳-cn - 博客园 (cnblogs.com)](</p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql为什么选用B+树</title>
      <link href="/2021/07/04/MySql%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E7%94%A8B-%E6%A0%91/"/>
      <url>/2021/07/04/MySql%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E7%94%A8B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql为什么选用B-树"><a href="#MySql为什么选用B-树" class="headerlink" title="MySql为什么选用B+树"></a>MySql为什么选用B+树</h1><p><strong>参考于：<a href="https://www.nowcoder.com/discuss/669322?channel=-1&source_id=profile_follow_post_nctrack">为什么选择b+树作为存储引擎索引结构_技术交流_牛客网 (nowcoder.com)</a></strong></p><p><strong>这篇文章写的比较详细！</strong>！！</p><ol><li>B树时间复杂度为O（logn）</li><li>B树支持范围查询、排序等操作</li><li>B树比其他的平衡二次树更加矮胖（准确点说应该是多路查找树）</li><li>B树的一个结点（页）为16KB，而操作系统的页为4KB，可以直接顺序读4个页，减少了随机IO次数</li><li>B+树由于将数据全部存储在叶子结点上，非叶子结点上可以存储更多的键，所以B+树比B树更矮，所以时间复杂度更低（还是应该说是查询任何数据的时间复杂度都差不多？）</li><li>B+树由于将数据全部存储在叶子结点上，并且用指针连接起来，形成了一个双向链表，扫库扫表能力更强</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SrpingBoot整合PageHelper</title>
      <link href="/2021/07/04/SrpingBoot%E6%95%B4%E5%90%88PageHelper/"/>
      <url>/2021/07/04/SrpingBoot%E6%95%B4%E5%90%88PageHelper/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot-Mybatis-Thymeleaf-Pagehelper"><a href="#SpringBoot-Mybatis-Thymeleaf-Pagehelper" class="headerlink" title="SpringBoot+Mybatis+Thymeleaf+Pagehelper"></a>SpringBoot+Mybatis+Thymeleaf+Pagehelper</h1><h2 id="1-在pom-xml中导入依赖"><a href="#1-在pom-xml中导入依赖" class="headerlink" title="1.在pom.xml中导入依赖"></a>1.在pom.xml中导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-在application-yml中添加配置"><a href="#2-在application-yml中添加配置" class="headerlink" title="2.在application.yml中添加配置"></a>2.在application.yml中添加配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pagehelper分页插件配置</span></span><br><span class="line"><span class="attr">pagehelper:</span></span><br><span class="line">  <span class="attr">helper-dialect:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">reasonable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">support-methods-arguments:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">params:</span> <span class="string">count=countSql</span></span><br></pre></td></tr></table></figure><h2 id="3-编写sql语句"><a href="#3-编写sql语句" class="headerlink" title="3.编写sql语句"></a>3.编写sql语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">--这里的sql语句只是举例，无任何实际含义--&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;getAllBlog&quot; resultMap<span class="operator">=</span>&quot;blog&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_blog   </span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这里请注意不要加’;’!!! **    因为pagehelper是在sql语句的后面追加’limit 5(这里’5’只是举例，无任何实际含义)，如果在sql语句后面加了’;’，那么sql语句就变成了</strong>‘select * from t_blog;limit 5’**,此时就会报错。</p><h2 id="4-编写Controller"><a href="#4-编写Controller" class="headerlink" title="4.编写Controller"></a>4.编写Controller</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhb.blogs.controller.admin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageInfo;</span><br><span class="line"><span class="keyword">import</span> com.zhb.blogs.pojo.Blog;</span><br><span class="line"><span class="keyword">import</span> com.zhb.blogs.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.zhb.blogs.service.BlogService;</span><br><span class="line"><span class="keyword">import</span> com.zhb.blogs.service.TagService;</span><br><span class="line"><span class="keyword">import</span> com.zhb.blogs.service.TypeService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.support.RedirectAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlogController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BlogService blogService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/blogs&quot;)</span>  <span class="comment">//后台显示博客列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">blogs</span><span class="params">(<span class="meta">@RequestParam(required = false,defaultValue = &quot;1&quot;,value = &quot;pagenum&quot;)</span><span class="keyword">int</span> pagenum, Model model)</span></span>&#123;</span><br><span class="line">        PageHelper.startPage(pagenum, <span class="number">5</span>);</span><br><span class="line">        List&lt;Blog&gt; allBlog = blogService.getAllBlog();<span class="comment">//获取所有blog</span></span><br><span class="line">        PageInfo pageInfo = <span class="keyword">new</span> PageInfo(allBlog);<span class="comment">//得到分页结果对象</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;pageInfo&quot;</span>, pageInfo);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin/blogs&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-编写前端"><a href="#5-编写前端" class="headerlink" title="5.编写前端"></a>5.编写前端</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui floated pagination menu&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;ui blue info message&quot;</span>&gt;</span>当前第<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;pageInfo.pageNum&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>页，总<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;pageInfo.pages&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>页，共<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;pageInfo.total&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>条记录<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right aligned column&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ui right floated pagination menu&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;pageInfo.pages&gt;1&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/&#125;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/(pagenum=$&#123;pageInfo.hasPreviousPage&#125;?$&#123;pageInfo.prePage&#125;:1)&#125;&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/(pagenum=$&#123;pageInfo.hasNextPage&#125;? $&#123;pageInfo.nextPage&#125;:$&#123;pageInfo.pages&#125;)&#125;&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/(pagenum=$&#123;pageInfo.pages&#125;)&#125;&quot;</span>&gt;</span>尾页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-结果"><a href="#6-结果" class="headerlink" title="6.结果"></a>6.结果</h2><p><img src="https://i.loli.net/2021/04/18/7IcP8EVo9GdXFZw.png" alt="结果"></p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自动装配原理初探</title>
      <link href="/2021/07/04/Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/"/>
      <url>/2021/07/04/Springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="springBoot自动装配原理"><a href="#springBoot自动装配原理" class="headerlink" title="springBoot自动装配原理"></a>springBoot自动装配原理</h1><p>摘抄于<a href="https://www.cnblogs.com/shamo89/p/8184960.html%EF%BC%8Chttps://www.cnblogs.com/hellokuangshen/p/12450327.html">https://www.cnblogs.com/shamo89/p/8184960.html，https://www.cnblogs.com/hellokuangshen/p/12450327.html</a></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span><span class="comment">// 继承了Configuration，表示当前是配置类</span></span><br><span class="line"><span class="meta">@ComponentScan</span><span class="comment">// 自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</span></span><br><span class="line"><span class="comment">//@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IOC容器</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span><span class="comment">// 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span><span class="comment">// 自动配置包注册</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span><span class="comment">// 导入当前主程序类的 *同级以及子级*的包组件</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span><span class="comment">// 导入自动配置的组件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span>主要做了以下四件事情：</span><br><span class="line"><span class="number">1</span>、推断应用的类型是普通的项目还是Web项目</span><br><span class="line"><span class="number">2</span>、查找并加载所有可用初始化器，设置到initializers属性中</span><br><span class="line"><span class="number">3</span>、找出所有的应用程序监听器，设置到listeners属性中</span><br><span class="line"><span class="number">4</span>、推断并设置main方法的定义类，找到运行的主类</span><br></pre></td></tr></table></figure></blockquote><p>@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。</p><blockquote><p>注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">register(registry, <span class="keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">            <span class="comment">//new PackageImport(metadata).getPackageName()，它其实返回了当前主程序类的 *同级以及子级*的包组件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AutoConfigurationImportSelector 继承了 DeferredImportSelector 继承了 ImportSelector</span><br><span class="line"></span><br><span class="line">ImportSelector中声明了一个方法为：selectImports。</span><br><span class="line">AutoConfigurationImportSelector实现了这个方法：selectImports </span><br><span class="line">    作用是：加载外部文件（spring-boot-autoconfiguration下的META-INF/spring.factories）</span><br><span class="line">    这个外部文件，有很多自动配置的类</span><br></pre></td></tr></table></figure><p><img src="https://img2018.cnblogs.com/blog/1335795/201810/1335795-20181025172502394-39889528.jpg" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1112095/201811/1112095-20181115230505205-305138350.png" alt="img"></p><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200309184347408-1065424525.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务</title>
      <link href="/2021/07/04/Spring%E4%BA%8B%E5%8A%A1/"/>
      <url>/2021/07/04/Spring%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h2><p>就是数据库的4个隔离级别+1个Spring默认隔离级别</p><ul><li>Spring默认隔离级别：oracle为读已提交，mysql为可重复读</li><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>序列化</li></ul><h2 id="Spring事务的传播级别"><a href="#Spring事务的传播级别" class="headerlink" title="Spring事务的传播级别"></a>Spring事务的传播级别</h2><p>有事务A、B，事务A中调用事务B，A为父事务，B为子事务</p><p>传播级别用于修饰B</p><p>保证同一个事务中</p><ul><li>REQUIRED 支持当前事务，如果不存在 就新建一个(默认)</li><li>SUPPORTS 支持当前事务，如果不存在，就不使用事务</li><li>MANDATORY 支持当前事务，如果不存在，抛出异常</li></ul><p>保证没有在同一个事务中</p><ul><li>REQUIRES_NEW 如果有事务存在，挂起当前事务，创建一个新的事务</li><li>NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务</li><li>NEVER 以非事务方式运行，如果有事务存在，抛出异常</li><li>NESTED 如果当前事务存在，则嵌套事务执行（父事务回滚，子事务一定回滚，但是子事务回滚，不影响父事务回滚）</li></ul><h2 id="Spring事务什么时候会失效"><a href="#Spring事务什么时候会失效" class="headerlink" title="Spring事务什么时候会失效"></a>Spring事务什么时候会失效</h2><ul><li><p>自调用</p><ul><li>类中调用本类的方法，解决办法：设置为代理类，由代理类来执行</li></ul></li><li><p>方法不是public</p><ul><li>@Transactionl（注解方式）只能用于public方法，否则事务会失效</li></ul></li><li><p>数据库不支持事务</p></li><li><p>没有交由Spring管理</p></li><li><p>异常被吃掉，事务不会回滚（或者抛出的异常未被定义，默认为运行时异常）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring循环依赖的解决</title>
      <link href="/2021/07/04/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2021/07/04/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring循环依赖的解决"><a href="#Spring循环依赖的解决" class="headerlink" title="Spring循环依赖的解决"></a>Spring循环依赖的解决</h1><p>参考于：<a href="https://www.cnblogs.com/daimzh/p/13256413.html">面试必杀技，讲一讲Spring中的循环依赖 - 程序员DMZ - 博客园 (cnblogs.com)</a></p><p>小提示：一级缓存为单例池</p><p>有A、B两个Bean</p><ol><li>二级缓存（未使用AOP）<ol><li>只需存储一个A的原始对象（二级缓存），当B注入A时，获取当A的原始对象</li><li>通过A对象创建一个工厂（三级缓存），当B注入A时，从工厂中获取一个A对象（其实可以直接用上面一种方式）</li></ol></li><li>三次缓存（使用了AOP）<ol><li>通过A对象创建一个工厂（三级缓存），当B注入A时，从工厂中获取一个<strong>A对象的代理对象</strong></li></ol></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>了解详细请前往：<a href="https://www.cnblogs.com/daimzh/p/13256413.html">面试必杀技，讲一讲Spring中的循环依赖 - 程序员DMZ - 博客园 (cnblogs.com)</a></strong></p><p>面试官：”Spring是如何解决的循环依赖？“</p><p>答：Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（<code>singletonObjects</code>）,二级缓存为早期曝光对象<code>earlySingletonObjects</code>，三级缓存为早期曝光对象工厂（<code>singletonFactories</code>）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p><p>面试官：”为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？“</p><p>答：如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中Bean的生命周期</title>
      <link href="/2021/07/04/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2021/07/04/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring中Bean的生命周期"><a href="#Spring中Bean的生命周期" class="headerlink" title="Spring中Bean的生命周期"></a>Spring中Bean的生命周期</h1><p>参考于：<a href="https://zhuanlan.zhihu.com/p/344140024">面试官：请你说一下 Bean 的生命周期 - 知乎 (zhihu.com)</a></p><ol><li>实例化Bean对象</li><li>属性注入<ol><li>构造器注入</li><li>setter方法注入</li><li>接口注入</li></ol></li><li>检测Aware接口<ol><li>BeanNameAware<ol><li>如果有实现，则调用setBeanName方法</li></ol></li><li>BeanFactoryAware<ol><li>如果有实现，则调用setBeanFactory方法</li></ol></li><li>ApplicationContextAware<ol><li>如果有实现，则调用setApplicationContext方法</li></ol></li></ol></li><li>检测BeanPostProcessor接口<ol><li>如果有实现，则调用postProcessBeforeInitialization()方法</li></ol></li><li>检测InitializingBean接口<ol><li>如果有实现，则调用afterPropertiesSet()方法</li><li>如果Bean有使用init-method声明初始化方法，就调用该初始化方法</li></ol></li><li>检测BeanPostProcessor接口<ol><li>如果有实现，则调用postProcessAfterInitialization()方法</li></ol></li><li>初始化完成，可以被使用</li><li>检测DisposableBean接口<ol><li>如果有实现，则调用destory()方法</li><li>如果Bean有使用destory-method声明销毁方法，就调用该销毁方法</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String、StringBuffer、StringBuilder</title>
      <link href="/2021/07/04/String%E3%80%81StringBuffer%E3%80%81StringBuilder/"/>
      <url>/2021/07/04/String%E3%80%81StringBuffer%E3%80%81StringBuilder/</url>
      
        <content type="html"><![CDATA[<h1 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>【两种实例化方式的区别】</p><ol><li><p> 直接赋值（String str = “hello”;）:只开辟一块堆内存空间，并且会自动入池，不会产生垃圾。</p></li><li><p> 构造方法（String str= new String(“hello”);）:会开辟两块堆内存空间，其中一块堆内存会变成垃圾被系统回收，而且不能够自动入池，需要通过public String intern();方法进行手工入池。</p></li><li><p>在开发的过程中不会采用构造方法进行字符串的实例化</p><p><img src="https://i.loli.net/2021/04/24/oE92PriqN3Gkf1j.png" alt="构造方法赋值"></p></li></ol><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        toStringCache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行速度"><a href="#执行速度" class="headerlink" title="执行速度"></a>执行速度</h2><p>在大多数情况下三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String</p><p>详情请前往：<a href="https://blog.csdn.net/rmn190/article/details/1492013">String,StringBuffer与StringBuilder的区别??_Java天空-CSDN博客</a> 或者 <a href="https://www.kuangstudy.com/">首页-KuangStudy</a>查询</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><p>String 字符串常量</p></li><li><p>StringBuffer 字符串变量（线程安全）</p></li><li><p>StringBuilder 字符串变量（非线程安全，执行速度最快）</p></li><li><p>对于三者使用的总结：</p><p>1）如果要操作少量的数据用 = String</p><p>2）单线程操作字符串缓冲区下操作大量数据 = StringBuilder</p><p>3）多线程操作字符串缓冲区下操作大量数据 = StringBuffer</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>url访问过程</title>
      <link href="/2021/07/04/url%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/07/04/url%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="当你从浏览器地址栏中输入URL回车后发生了什么"><a href="#当你从浏览器地址栏中输入URL回车后发生了什么" class="headerlink" title="当你从浏览器地址栏中输入URL回车后发生了什么"></a>当你从浏览器地址栏中输入URL回车后发生了什么</h1><p>参考于：<a href="https://blog.csdn.net/u013363501/article/details/63692528">当你从浏览器地址栏中输入URL回车后发生了什么_千里之行，始于足下-CSDN博客</a></p><ol><li><p>在浏览器中输入域名</p><p>例如<a href="http://www.zhuhebin.com/">www.zhuhebin.com</a></p></li><li><p>查询浏览器缓存</p></li><li><p>查询本机的hosts文件(C:\Windows\System32\drivers\etc\hosts)</p></li><li><p>查询本地域名服务器</p></li><li><p>由本地域名服务器去访问根域名服务器，获取顶级域名服务器”com”的IP地址</p></li><li><p>由本地域名服务器去访问顶级域名服务器，获取权限域名服务器”zhb.com”的IP地址</p></li><li><p>由本地域名服务器去访问权限域名服务器，获取”<a href="http://www.zhuhebin.com&quot;的ip地址/">www.zhuhebin.com&quot;的IP地址</a></p></li><li><p>本地域名服务器将查询结果返回主机(此时本地域名服务器会保留一份缓存)</p></li><li><p>主机访问该域名</p></li><li><p>发起TCP的三次握手</p><ol><li>A–&gt;B   SYN=1,seq=x</li><li>B–&gt;A   SYN=1,ACK=1,ack=x+1,seq=y</li><li>A–&gt;B   ACK=1,ack=y+1,seq=x+1</li></ol></li><li><p>在建立TCP连接后，发起HTTP请求</p></li><li><p>服务器给浏览器进行一个301永久重定向响应。(该IP对应的服务器很可能是代理服务器，比如你输入“<a href="http://baidu.com/">http://baidu.com</a>”,而不是“<a href="http://www.baidu.com/">http://www.baidu.com</a>”,按道理这两个网址对应的是同一个网页，因此通过代理服务器的方式进行重定向相应，让这两个网址访问的是同一个网页。)</p></li><li><p>浏览器根据重定向地址再次进行HTTP请求</p></li><li><p>服务器接受请求并返回 HTTP 响应</p></li><li><p>客户端浏览器解析 HTML 内容</p></li><li><p>……</p></li><li><p>释放TCP连接(四次挥手)</p><ol><li>A–&gt;B  FIN=1,seq=u</li><li>B–&gt;A  ACK=1,ack=u+1,seq=v</li><li>B–&gt;A  FIN=1,ACK=1,ack=u+1,seq=w</li><li>A–&gt;B  ACK=1,ack=w+1,seq=u+1</li><li>A会再等待2MSL(最长报文段寿命)，确保B接收到A的响应</li></ol></li></ol><p><img src="https://i.loli.net/2021/05/15/Lh1j2xBWNHKP4gO.png" alt="访问网址.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> url </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程小结</title>
      <link href="/2021/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程小结"><a href="#多线程小结" class="headerlink" title="多线程小结"></a>多线程小结</h1><p>参考于：<a href="https://www.kuangstudy.com/">首页-KuangStudy</a> </p><p><a href="https://blog.csdn.net/pange1991/article/details/53860651">https://blog.csdn.net/pange1991/article/details/53860651</a></p><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义，线程可以利用进程所有拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ol><li><p>继承Thread类(lamda表达式：new Thread（()-&gt;System.out.println(“多线程学习。。。。”)）.start();)</p><ol><li>自定义线程类继承Thread类</li><li>重写run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li></ol></li><li><p>实现Runnable接口(推荐使用，因为Java单继承的局限性)</p><ol><li>自定义实现Runnable接口</li><li>实现run()方法，编写线程执行体</li><li>创建线程对象，调用start()方法启动线程</li></ol></li><li><p>实现Callable接口</p><ol><li>实现Callable接口，需要返回值类型 </li><li>重写call()方法，需要抛出异常</li><li>创建目标对象<ol><li>方式一：通过线程池<ul><li>创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1); </li><li>提交执行：Future<Boolean> future = ser.submit(callable); </li><li>获取结果：boolean r1 = future .get() </li><li>关闭服务：ser.shutdownNow();</li></ul></li><li>方式二：FutureTask（适配类）<ul><li>FutureTask futureTask = new FutureTask(myThread); // 适配类 </li><li>new Thread(futureTask,”A”).start(); // 调用执行 </li><li>Integer result = (Integer) futureTask.get(); // 获取返回值 </li></ul></li></ol></li></ol></li><li><p>创建线程池</p><ol><li><p>使用Executors的静态方法（不推荐使用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有且只有一个固定的线程</span></span><br><span class="line">ExecutorService threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//创建一个线程池，一池有N个固定的线程，有固定线程数的线程</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);<span class="comment">//执行长期任务性能好</span></span><br><span class="line"><span class="comment">//线程池根据需要创建新线程，但在先构建的线程可用时将重用他们。可扩容，遇强则强</span></span><br><span class="line">ExecutorService threadPool = Executors.newCachedThreadPool();<span class="comment">//执行很多短期异步任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*阿里巴巴Java开发手册</span></span><br><span class="line"><span class="comment">*4. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样</span></span><br><span class="line"><span class="comment">*的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</span></span><br><span class="line"><span class="comment">*说明：Executors 返回的线程池对象的弊端如下： </span></span><br><span class="line"><span class="comment">*    1）FixedThreadPool 和 SingleThreadPool:</span></span><br><span class="line"><span class="comment">*允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</span></span><br><span class="line"><span class="comment">*    2）CachedThreadPool 和 ScheduledThreadPool:</span></span><br><span class="line"><span class="comment">*允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>线程池源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>线程池源码解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> corePoolSize,//核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。</span></span></span><br><span class="line"><span class="params"><span class="function">    //默认情况下，在创建了线程池后，线程池中的线程数为<span class="number">0</span>，</span></span></span><br><span class="line"><span class="params"><span class="function">    //当有任务来之后，就会创建一个线程去执行任务，</span></span></span><br><span class="line"><span class="params"><span class="function">    //当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> maximumPoolSize,//最大线程数。表明线程中最多能够创建的线程数量，此值必须大于等于<span class="number">1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">long</span> keepAliveTime,//空闲的线程保留的时间。</span></span></span><br><span class="line"><span class="params"><span class="function">    TimeUnit unit,//空闲线程的保留时间单位</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">/*</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    TimeUnit.DAYS; //天 </span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    TimeUnit.HOURS; //小时 </span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    TimeUnit.MINUTES; //分钟 </span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    TimeUnit.SECONDS; //秒</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">        TimeUnit.MILLISECONDS; //毫秒 </span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">        TimeUnit.MICROSECONDS; //微妙 </span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">        TimeUnit.NANOSECONDS; //纳秒</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue可选</span></span></span><br><span class="line"><span class="params"><span class="function">    ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span></span><br><span class="line"><span class="params"><span class="function">    RejectedExecutionHandler handler//拒绝策略。阻塞队列已满，且任务量大于最大线程的异常处理策略。参数有</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">/*</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。 </span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务 （重复此过程） ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span></span><br></pre></td></tr></table></figure></li><li><p>创建线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor( <span class="number">2</span>,<span class="number">5</span>,<span class="number">2L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br></pre></td></tr></table></figure></li><li><p>ThreadPoolExecutor 底层工作原理</p><p><img src="https://i.loli.net/2021/04/25/zH5G6CfaX1Kv8QP.jpg" alt="1"></p></li></ol></li></ol><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java线程的6种状态及切换(透彻讲解)</strong> 原文链接：<a href="https://blog.csdn.net/pange1991/article/details/53860651">https://blog.csdn.net/pange1991/article/details/53860651</a></p><ol><li><p>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</p></li><li><p>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</p></li><li><p>阻塞(BLOCKED)：表示线程阻塞于锁。</p></li><li><p>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p></li><li><p>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</p></li><li><p>终止(TERMINATED)：表示该线程已经执行完毕。</p><p><img src="https://i.loli.net/2021/04/25/wJBmAokNiKI5M76.jpg" alt="线程的状态图"></p></li></ol><h2 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h2><ol><li><strong>互斥</strong>条件：一个资源每次只能被一个进程使用。</li><li><strong>请求与保持</strong>条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不可剥夺</strong>条件 : 进程已获得的资源，在末使用完之前，不能强行剥夺。 </li><li><strong>循环等待</strong>条件 : 若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h2 id="Synchronized-与-Lock-的对比"><a href="#Synchronized-与-Lock-的对比" class="headerlink" title="Synchronized 与 Lock 的对比"></a>Synchronized 与 Lock 的对比</h2><ol><li><p>首先synchronized是java内置关键字，在jvm层面；Lock是个java类，是api层面的锁；</p></li><li><p>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</p></li><li><p>Lock只有代码块锁，synchronized有代码块锁和方法锁 </p></li><li><p>使用Lock锁，JVM将花费较少的时间来调度线程，性能好。并且具有更好的扩展性（提供更多的子类）</p></li><li><p>**synchronized(隐式锁)<strong>会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，</strong>Lock(显式锁)**需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</p></li><li><p>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</p></li><li><p><strong>synchronized的锁可重入、不可中断、非公平</strong>，而<strong>Lock锁可重入、可中断、可公平</strong>（两者皆可）</p><p><a href="https://www.cnblogs.com/aspirant/p/6930436.html">JAVA锁机制-可重入锁,可中断锁，公平锁，读写锁，自旋锁-  博客园 (cnblogs.com)</a></p></li><li><p>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p><p><strong>提示：</strong>Synchronized中<strong>不使用if而使用while可以防止虚假唤醒</strong></p></li></ol><h2 id="wait-sleep-的区别"><a href="#wait-sleep-的区别" class="headerlink" title="wait / sleep 的区别"></a>wait / sleep 的区别</h2><ol><li><p><strong>来自不同的类</strong></p><p>这两个方法来自不同的类分别是，<strong>sleep来自Thread类，和wait来自Object类</strong>。</p><p>sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。</p></li><li><p><strong>有没有释放锁(释放资源)</strong></p><p>最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</p><p>sleep是线程被调用时，占着cpu去睡觉，其他线程不能占用cpu，os认为该线程正在工作，不会让出系统资源，wait是进入等待池等待，让出系统资源，其他线程可以占用cpu。</p></li><li><p><strong>使用范围不同</strong></p><p>wait、notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用</p></li><li><p><strong>是否需要捕获异常</strong></p><p>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常。</p></li></ol><h2 id="8锁问题"><a href="#8锁问题" class="headerlink" title="8锁问题"></a>8锁问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 多线程的8锁 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 1、标准访问，请问先打印邮件还是短信？ </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 2、邮件方法暂停4秒钟，请问先打印邮件还是短信？ </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 3、新增一个普通方法hello()没有同步,请问先打印邮件还是hello？ </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 4、两部手机、请问先打印邮件还是短信？ </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 5、两个静态同步方法，同一部手机，请问先打印邮件还是短信？ </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 6、两个静态同步方法，2部手机，请问先打印邮件还是短信？ </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 7、一个普通同步方法，一个静态同步方法，同一部手机，请问先打印邮件还是短信？ </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 8、一个普通同步方法，一个静态同步方法，2部手机，请问先打印邮件还是短信？ </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>synchronized实现同步的基础：java中的每一个对象都可以作为锁具体的表现为以下三种形式：</p><p><strong>对于同步代码块，锁是synchronized括号里面的配置对象</strong></p><p><strong>对于普通同步方法，锁的是当前实例对象</strong></p><p><strong>对于静态同步方法，锁的是当前的Class对象。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/2021/07/04/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2021/07/04/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><strong>内部类</strong></h1><p>参考于：<a href="https://www.jianshu.com/p/0d0bd9046039">https://www.jianshu.com/p/0d0bd9046039</a></p><p><a href="https://www.kuangstudy.com/">https://www.kuangstudy.com/</a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>内部类就是在一个类的内部在定义一个类</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>内部类方法可以访问该类定义所在的作用域的数据，包括私有的数据</li><li>内部类可以对同一个包中的其他类隐藏起来,一般的非内部类，是不允许有 private 与protected权限的，但内部类可以</li><li>可以实现多重继承</li><li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>内部类分为四种：</p><ul><li>成员内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li></ul><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;这是外部类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;这是内部类方法&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="comment">//实例化成员内部类分两步 </span></span><br><span class="line"><span class="comment">//1、实例化外部类 </span></span><br><span class="line">Outer outObject = <span class="keyword">new</span> Outer(); </span><br><span class="line"><span class="comment">//2、通过外部类调用内部类 </span></span><br><span class="line">Outer.Inner inObject = outObject.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//测试，调用内部类中的方法 </span></span><br><span class="line">    inObject.in();<span class="comment">//打印：这是内部类方法 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;这是外部类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;这是静态内部类方法&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="comment">//实例化静态内部类</span></span><br><span class="line">    <span class="comment">//静态内部类能够直接被外部类给实例化，不需要使用外部类对象</span></span><br><span class="line">Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><strong>静态类不能访问非静态属性，包括自己类的非静态属性</strong></li></ul><p>提醒：</p><ul><li>static修饰成员变量：整个类的实例共享静态变量</li><li>static修饰方法：静态方法，只能够访问用static修饰的属性或方法，而非静态方法可以访问static修饰的方法或属性</li><li>被static修饰了的成员变量和方法能直接被类名调用。</li><li>static不能修饰局部变量，切记，不要搞混淆了，static平常就用来修饰成员变量和方法。</li></ul><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123; </span><br><span class="line">System.out.println(<span class="string">&quot;这是外部类方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是局部内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Inner In = <span class="keyword">new</span> Inner();</span><br><span class="line">        In.in();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li><strong>如果要访问局部变量，那么该局部变量要用final修饰</strong></li><li>原因：如果不用final修饰，当局部内部类被实例化后，方法弹栈，局部变量随之跟着消失，这个时候局部内部类对象在想去调用该局部变量，就会报错，因为该局部变量已经没了，当局部变量用final修饰后，就会将其加入常量池中，即使方法弹栈了，该局部变量还在常量池中呆着，局部内部类也就还能够调用</li></ul><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名对象：如果一个对象只要使用一次，那么我们只需要new Object().method()，而不需要给这个实例保存到该类型变量中去。</p><p>匿名内部类：我也只需要用一次，那我就不需要在类中先定义一个内部类，而是等待需要用的时候，我就在临时实现这个内部类，因为用次数少，可能就这一次，那么这样写内部类，更方便。<strong>工作中可能遇到的最多</strong></p><ol><li><p>匿名内部类需要依托于其他类或者接口来创建</p><ul><li><p>如果依托的是类,那么创建出来的匿名内部类就默认是这个类的子类</p></li><li><p>如果依托的是接口,那么创建出来的匿名内部类就默认是这个接口的实现类。</p></li></ul></li><li><p>匿名内部类的声明必须是在使用new关键字的时候</p><ul><li>匿名内部类的声明及创建对象必须一气呵成,并且之后能反复使用,因为没有名字。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="comment">//如果我们需要使用接口中的方法，我们只需要走一步，就是使用匿名内部类，直接将其 类的对象创建出来。 </span></span><br><span class="line">        <span class="keyword">new</span> Test1()&#123; </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;实现了Test1接口的方法&quot;</span>); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;.method();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test1</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何处理慢查询</title>
      <link href="/2021/07/04/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
      <url>/2021/07/04/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%85%A2%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="如何处理慢查询"><a href="#如何处理慢查询" class="headerlink" title="如何处理慢查询"></a>如何处理慢查询</h1><p>思路：</p><ol><li>SQL优化</li><li>索引优化</li><li>表结构和存储引擎</li><li>数据库配置</li><li>硬件和操作系统</li></ol><p>小结：</p><ol><li>检查是否查询了多余的列，如何只需要查询id和name，结果select *。</li><li>explain SQL 查看是否走了索引</li><li>如果是联合索引，查看是否走了联合索引（将范围查询的条件放在联合索引的后面，如果联合索引abc，a=1 and b&gt;2 and c=3,这样只走了a=1 and b&gt;2，联合索引要满足最左匹配原则，遇到范围查询就会停下来）</li><li>避免null数据</li><li>尽可能使用limit来减少数据量</li><li>尽可能地缩小数据类型的长度</li><li>尽量不使用站外的数据库</li><li>选用合适的数据库引擎</li><li>服务降级</li><li>分库分表</li><li>提高硬件水平</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java位运算小结</title>
      <link href="/2021/07/03/Java%E4%BD%8D%E8%BF%90%E7%AE%97%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/07/03/Java%E4%BD%8D%E8%BF%90%E7%AE%97%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Java位运算符小结"><a href="#Java位运算符小结" class="headerlink" title="Java位运算符小结"></a>Java位运算符小结</h1><p>参考文章：<a href="https://www.cnblogs.com/SunArmy/p/9837348.html">Java 位运算符 &amp;、|、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;)</a></p><h2 id="与运算符（-amp-）"><a href="#与运算符（-amp-）" class="headerlink" title="与运算符（&amp;）"></a>与运算符（&amp;）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同为1，取1，否则为0</span></span><br><span class="line"><span class="comment">//例如：4&amp;7</span></span><br><span class="line"><span class="comment">//4：0000 0100</span></span><br><span class="line"><span class="comment">//7：0000 0111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4：0000 0100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即 4&amp;7=4</span></span><br></pre></td></tr></table></figure><h2 id="或运算符（-）"><a href="#或运算符（-）" class="headerlink" title="或运算符（|）"></a>或运算符（|）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同为0，取0，否则为1</span></span><br><span class="line"><span class="comment">//例如：5|9</span></span><br><span class="line"><span class="comment">//5：0000 0101</span></span><br><span class="line"><span class="comment">//9：0000 1001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//13：0000 1101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即 5|9=13</span></span><br></pre></td></tr></table></figure><h2 id="异或运算符（-）"><a href="#异或运算符（-）" class="headerlink" title="异或运算符（^）"></a>异或运算符（^）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同为1，否则为0   另一种理解：无进位相加</span></span><br><span class="line"><span class="comment">//例如：15^7</span></span><br><span class="line"><span class="comment">//15：0000 1111</span></span><br><span class="line"><span class="comment">//7：0000 0111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8：0000 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即 15^7=8</span></span><br></pre></td></tr></table></figure><h2 id="取反运算符（-）"><a href="#取反运算符（-）" class="headerlink" title="取反运算符（~）"></a>取反运算符（~）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取反</span></span><br><span class="line"><span class="comment">//例如：~15</span></span><br><span class="line"><span class="comment">//15：0000 1111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-16：1111 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即 ~15=-16</span></span><br></pre></td></tr></table></figure><h2 id="左移运算符（-lt-lt-）"><a href="#左移运算符（-lt-lt-）" class="headerlink" title="左移运算符（&lt;&lt;）"></a>左移运算符（&lt;&lt;）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左移</span></span><br><span class="line"><span class="comment">//例如：12&lt;&lt;3</span></span><br><span class="line"><span class="comment">//12：0000 1100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//96：0110 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即 12&lt;&lt;3=96</span></span><br></pre></td></tr></table></figure><h2 id="右移运算符（-gt-gt-）"><a href="#右移运算符（-gt-gt-）" class="headerlink" title="右移运算符（&gt;&gt;）"></a>右移运算符（&gt;&gt;）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右移（有符号位右移,补位与符号位相同）</span></span><br><span class="line"><span class="comment">//例如：12&gt;&gt;2</span></span><br><span class="line"><span class="comment">//12：0000 1100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3：0000 0011</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即 12&gt;&gt;2=3</span></span><br><span class="line"><span class="comment">/*************************/</span></span><br><span class="line"><span class="comment">//例如：-8&gt;&gt;2</span></span><br><span class="line"><span class="comment">//-8：1111 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-2：1111 1110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即 -8&gt;&gt;2=-2</span></span><br></pre></td></tr></table></figure><h2 id="无符号右移（-gt-gt-gt-）"><a href="#无符号右移（-gt-gt-gt-）" class="headerlink" title="无符号右移（&gt;&gt;&gt;）"></a>无符号右移（&gt;&gt;&gt;）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右移（无符号位右移，补位为0）</span></span><br><span class="line"><span class="comment">//例如：12&gt;&gt;2</span></span><br><span class="line"><span class="comment">//12：0000 1100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3：0000 0011</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即 12&gt;&gt;&gt;2=3</span></span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="取某数字的二进制最右边的1"><a href="#取某数字的二进制最右边的1" class="headerlink" title="取某数字的二进制最右边的1"></a>取某数字的二进制最右边的1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N &amp; ( ~N + 1 )</span></span><br><span class="line"><span class="comment">//例如：12&amp;(~12+1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//12：0000 1100</span></span><br><span class="line"><span class="comment">//~12:1111 0011</span></span><br><span class="line"><span class="comment">//~12+1:1111 0100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//12：0000 1100</span></span><br><span class="line"><span class="comment">//~12+1:1111 0100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4:0000 0100</span></span><br></pre></td></tr></table></figure><h3 id="交换两个数，无额外空间消耗"><a href="#交换两个数，无额外空间消耗" class="headerlink" title="交换两个数，无额外空间消耗"></a>交换两个数，无额外空间消耗</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swapNum</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">    num1 ^= num2;</span><br><span class="line">    num2 ^= num1;</span><br><span class="line">    num1 ^= num2;</span><br><span class="line">    System.out.println(num1);</span><br><span class="line">    System.out.println(num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个数组中只有一种数出现了奇数次，其他数出现了偶数次，找出这种数"><a href="#一个数组中只有一种数出现了奇数次，其他数出现了偶数次，找出这种数" class="headerlink" title="一个数组中只有一种数出现了奇数次，其他数出现了偶数次，找出这种数"></a>一个数组中只有一种数出现了奇数次，其他数出现了偶数次，找出这种数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//偶数个相同的数 异或 一定为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOneNum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个数组中有两种数出现了奇数次，其他数出现了偶数次，找出这种数"><a href="#一个数组中有两种数出现了奇数次，其他数出现了偶数次，找出这种数" class="headerlink" title="一个数组中有两种数出现了奇数次，其他数出现了偶数次，找出这种数"></a>一个数组中有两种数出现了奇数次，其他数出现了偶数次，找出这种数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//偶数个相同的数 异或 一定为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTwoNum</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="comment">//假设这两个数为a，b  因为a,b为奇数个，那么最后eor=a^b</span></span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这道题中请把a，b都转换成二进制来分析！！！</span></span><br><span class="line">    <span class="comment">//这道题中请把a，b都转换成二进制来分析！！！</span></span><br><span class="line">    <span class="comment">//这道题中请把a，b都转换成二进制来分析！！！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rightOne=eor &amp; (~eor+<span class="number">1</span>);<span class="comment">//取a^b最右边的1</span></span><br><span class="line">    <span class="keyword">int</span> onlyOne=<span class="number">0</span>;<span class="comment">//用于取出a或b中的一个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//由题可知a，b不同且为奇数个，其他数为偶数个</span></span><br><span class="line">        <span class="comment">//由rightOne得到a，b的其中一个不同之处</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//因为偶数个相同的数 异或 一定为0</span></span><br><span class="line">        <span class="comment">//所以可以理解为：a，b个数均为1</span></span><br><span class="line">        <span class="comment">//设其他数为c、d、e...</span></span><br><span class="line">        <span class="comment">//此处将a，b分为  a，cc，dd...  和  b，ee，ff...</span></span><br><span class="line">        <span class="keyword">if</span> ((arr[i] &amp; rightOne)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//所以最后onlyOne为a或者b，再把它与eor异或得出另一个数</span></span><br><span class="line">            onlyOne ^= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(onlyOne);</span><br><span class="line">    System.out.println(onlyOne^eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态响应码</title>
      <link href="/2021/07/03/%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81/"/>
      <url>/2021/07/03/%E7%8A%B6%E6%80%81%E5%93%8D%E5%BA%94%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="状态响应码"><a href="#状态响应码" class="headerlink" title="状态响应码"></a>状态响应码</h1><p>参考于：<a href="https://www.cnblogs.com/isykw/p/6115469.html">HTTP状态码(响应码) - isykw - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/lghuntfor/article/details/88606444">HTTP响应状态码详解_lghuntfor的专栏-CSDN博客_状态响应码</a></p><h2 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h2><ul><li>1XX：信息</li><li>2XX：成功</li><li>3XX：重定向</li><li>4XX：客户端错误</li><li>5XX：服务器错误</li></ul><h2 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h2><ul><li>100：继续输入</li><li>101：切换协议</li><li>200：响应成功</li><li>302：重定向</li><li>307：转发</li><li>401：身份验证</li><li>403：禁止访问</li><li>404：资源不存在</li><li>500：服务器内部错误</li><li>502：网关错误</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/03/hello-world/"/>
      <url>/2021/07/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
